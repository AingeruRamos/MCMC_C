// Copyright Notice ===========================================================
//
// mcmc.h, Copyright (c) 2023 Aingeru Ramos
//
// All Rights Reserved ========================================================
//
// This file is part of MCMC_C software project.
//
// MCMC_C is propietary software. The author has all the rights to the work.
// No third party may make use of this work without explicit permission of the author.
//
// ============================================================================

#ifndef _MCMC_H_
#define _MCMC_H_

/**
 * @class IterationResult
 * @brief
 * * Instances of this class saves the data generated 
 * * by one iteration of the MCMC
*/
class IterationResult {
    public:
        /**
         * @name copy
         * @remark virtual
         * @return Copy of this IterationResult
         * @brief 
         * * Creates a copy of this IterationResult 
        */
        virtual IterationResult* copy() = 0; 
};

/**
 * @class ReplicaResult
 * @param _n_iterations Number of iterations
 * @param _act_iteration Actual iteration
 * @param _iteration_list List of iterations
 * @brief
 * * Instances of this class saves the data generated
 * * by multiple iterations of the MCMC algorithm
*/
class ReplicaResult {
    public:
        int _n_iterations;
        int _act_iteration;
        IterationResult** _iteration_list;

        /**
         * @name ReplicaResult
         * @remark constructor
         * @param n_iterations Number of iterations
        */
        ReplicaResult(int n_iterations);

        /**
         * @name push
         * @param it_res IterationResult to add
         * @brief
         * * Adds a IterationResult to the list
        */
        void push(IterationResult* it_res);

        /**
         * @name set
         * @param it_res IterationResult to add
         * @param iteration Position where set 'it_res'
         * @brief
         * * Puts 'it_res' in index 'iteration'
        */
        void set(IterationResult* it_res, int iteration);

        /**
         * @name get
         * @param iteration Index where get the IterationResult
         * @return The IterationResult in position 'iteration'
         * @brief
         * * Gets the IterationResult in position 'iteration'
        */
        IterationResult* get(int iteration);

        /**
         * @name pop
         * @return The last IterationResult of the list
         * @brief
         * * Gets the last IterationResult of the list
         * @note
         * This function doesnt eliminate tha last IterationResult.
         * Just returns the pointer to it.
        */
        IterationResult* pop();

        /**
         * @name copy
         * @remark virtual
         * @return A copy of this ReplicaResult
         * @brief
         * * Copies this instance of ReplicaResult
        */
        virtual ReplicaResult* copy();

        /**
         * @name print
         * @remark virtual
         * @brief
         * * Prints the list of results
        */
        virtual void print() = 0;

        /**
         * @name swap
         * @remark static
         * @param r1 A first ReplicaResult to swap
         * @param r2 A second ReplicaResult to swap
         * @param iteration Position to swap
         * @brief
         * * Swaps the position 'iteration' between the two ReplicaResult-s
        */
        static void swap(ReplicaResult* r1, ReplicaResult* r2, int iteration);
};

/**
 * @class ReplicaResult
 * @param _results Pointer to ReplicaResult where save the results
 * @brief
 * * Instances of this class can represent any given model
 * * and used a s a replica in the MCMC algorithm
*/
class Replica {
    public:

        ReplicaResult* _results;

        /**
         * @name trial
         * @remark virtual
         * @return A trial
         * @brief
         * * Generates a trial of the model
        */
        virtual void* trial() = 0;

        /**
         * @name eval
         * @remark virtual
         * @return Value of energy of the model
         * @brief
         * * Calculate the total energy of the model
        */
        virtual double eval() = 0;

        /**
         * @name delta
         * @remark virtual
         * @param trial A trial generated by 'trial'
         * @return Value of the difference of the actual model and 
         * the model result of apply the trial
         * @brief
         * * Calculate the effect of accept the trial
        */
        virtual double delta(void* trial) = 0;

        /**
         * @name move
         * @remark virtual
         * @param trial A trial generated by 'trial'
         * @brief
         * * Apply the trial to the model
        */
        virtual void move(void* trial) = 0;

        /**
         * @name save
         * @remark virtual
         * @param trial A trial generated by 'trial'
         * @brief
         * * Save the properties of the model
        */
        virtual void save(void* trial) = 0;
};

/**
 * @class Swap
 * @param _accepted Flag of accepted swap
 * @param _swap_candidate_1 Index of the first swap candidate
 * @param _swap_candidate_2 Index of the second swap candidate
 * @brief
 * * Instances of this class saves the planned swap between two replicas
*/
class Swap {
    public:
        bool _accepted;
        int _swap_candidate_1;
        int _swap_candidate_2;

        /**
         * @name Swap
         * @remark constructor
         * @param sw_cand_1 Index of the first swap candidate
         * @param sw_cand_2 Index of the second swap candidate
        */
        Swap(int sw_cand_1, int sw_cand_2);
};

/**
 * @name MCMC_iteration
 * @param model A Replica
 * @param temp Temperature to use for the simulation
 * @brief
 * * Does one iteration in MCMC algorithm in one Replica
*/
void MCMC_iteration(Replica* model, double temp);

/**
 * @name get_swap_prob
 * @param models Array of Replica-s
 * @param temps Array of temperatures
 * @return Probabilty to accept the swap
 * @brief
 * * Calculates the probability of accepting the swap
*/
double get_swap_prob(Swap* sw, Replica** models, double* temps);

#endif